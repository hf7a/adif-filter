"""
ADIF Filter
-----------
A GUI utility to parse, filter, merge, and re-save ADIF log files.
Features include merging multiple files, visual drag & drop, 
field filtering, and intelligent deduplication.

Author: Leszek HF7A
License: MIT
Version: 1.0.0
"""

import sys
import re
import chardet
from pathlib import Path
from typing import Dict, List, Set, Tuple, TypeAlias

from PyQt6.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QPushButton, QLabel, 
    QScrollArea, QCheckBox, QFileDialog, QMessageBox
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QDragEnterEvent, QDropEvent

__version__ = "1.0.0"

# Type aliases
AdifRecord: TypeAlias = Dict[str, str]

CONFIG_FILE_PATH = Path('adif_config.txt')

DEFAULT_FIELDS = [
    "BAND", "CALL", "FREQ", "MODE", "QSO_DATE", 
    "RST_RCVD", "RST_SENT", "TIME_ON"
]

# Fields used to identify a unique QSO for deduplication
DEDUPE_KEY_FIELDS = ["CALL", "BAND", "MODE", "QSO_DATE", "TIME_ON"]
GRID_COLUMNS = 3


class AdifProcessor:
    """Handles parsing, merging, filtering, and saving of ADIF data."""
    
    def __init__(self) -> None:
        self.records: List[AdifRecord] = []
        self.loaded_files: List[Path] = []

    def clear_data(self) -> None:
        self.records.clear()
        self.loaded_files.clear()

    def add_adif_files(self, file_paths: List[Path]) -> Tuple[int, int, List[str]]:
        """
        Reads multiple ADIF files.
        Returns: (new_records_count, total_records_count, list_of_errors)
        """
        new_records_count = 0
        errors = []
        
        for file_path in file_paths:
            try:
                raw_content = file_path.read_bytes()
                detected = chardet.detect(raw_content)['encoding'] or 'utf-8'
                decoded_content = raw_content.decode(detected, errors='replace')
                
                # Simple splitting by EOR tag. 
                # Note: This assumes <EOR> is not part of a comment or user field.
                raw_records = decoded_content.split('<EOR>')
                
                parsed_records = []
                for r in raw_records:
                    if r.strip():
                        fields = self._extract_fields(r)
                        # Only add if we actually extracted fields (ignores empty headers)
                        if fields:
                            parsed_records.append(fields)
                
                if parsed_records:
                    self.records.extend(parsed_records)
                    self.loaded_files.append(file_path)
                    new_records_count += len(parsed_records)
            except Exception as e:
                errors.append(f"{file_path.name}: {str(e)}")
        
        return new_records_count, len(self.records), errors

    def _extract_fields(self, record_text: str) -> AdifRecord:
        """
        Parses a single record string into a dictionary.
        Note: Uses regex for simplicity. A strict ADIF parser would respect 
        the length specifier <FIELD:LEN> to handle special characters inside fields.
        """
        pattern = re.compile(r'<(\w+):\d+>([^<]+)')
        return {
            m.group(1).upper(): m.group(2) 
            for m in pattern.finditer(record_text)
        }

    def save_adif_file(self, output_path: Path, selected_fields: Set[str], remove_duplicates: bool) -> Tuple[int, int]:
        """
        Writes filtered records to disk.
        Returns: (saved_count, duplicates_removed_count)
        """
        saved_count = 0
        duplicates_count = 0
        seen_qsos: Set[Tuple[str, ...]] = set()

        with output_path.open('w', encoding='utf-8', errors='ignore') as file:
            header = (
                f"Generated by ADIF Filter v{__version__}\n"
                f"<PROGRAMID:11>ADIF Filter\n<EOH>\n\n"
            )
            file.write(header)
            
            for record in self.records:
                if remove_duplicates:
                    # Create a unique key tuple based on critical fields
                    key = tuple(record.get(f, "").strip().upper() for f in DEDUPE_KEY_FIELDS)
                    if key in seen_qsos:
                        duplicates_count += 1
                        continue
                    seen_qsos.add(key)

                line_parts = []
                for field, value in record.items():
                    if field in selected_fields:
                        line_parts.append(f'<{field}:{len(value)}>{value}')
                
                if line_parts:
                    file.write(''.join(line_parts) + "<EOR>\n")
                    saved_count += 1
                    
        return saved_count, duplicates_count

    def get_unique_fields(self) -> List[str]:
        return sorted({k for r in self.records for k in r.keys()})

    @staticmethod
    def load_config() -> Set[str]:
        if not CONFIG_FILE_PATH.exists():
            try:
                CONFIG_FILE_PATH.write_text("\n".join(DEFAULT_FIELDS), encoding='utf-8')
            except IOError:
                return set(DEFAULT_FIELDS)
            
        try:
            content = CONFIG_FILE_PATH.read_text(encoding='utf-8')
            return {line.strip() for line in content.splitlines() if line.strip()}
        except IOError:
            return set()

    @staticmethod
    def save_config(selected_fields: Set[str]) -> None:
        try:
            CONFIG_FILE_PATH.write_text("\n".join(sorted(selected_fields)), encoding='utf-8')
        except IOError:
            pass


class AdifFilterWindow(QWidget):
    """Main GUI Application Window."""
    
    def __init__(self) -> None:
        super().__init__()
        self.setAcceptDrops(True)
        self.processor = AdifProcessor()
        self.field_checkboxes: Dict[str, QCheckBox] = {}
        self.saved_fields = self.processor.load_config()
        self._init_ui()

    def _init_ui(self) -> None:
        self.setWindowTitle("ADIF Filter by HF7A")
        self.setMinimumSize(550, 700)
        
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setSpacing(10)

        self._setup_drop_zone()
        self._setup_info_labels()
        self._setup_top_buttons()
        self._setup_instruction_label()
        self._setup_grid_area()
        self._setup_action_buttons()
        self._setup_options()
        self._setup_process_button()
        self._setup_footer()

    def _setup_drop_zone(self):
        self.label_drop_zone = QLabel("ðŸ“‚ Drag & Drop ADIF files here\n(You can drop multiple files to merge them)", self)
        self.label_drop_zone.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.label_drop_zone.setStyleSheet("""
            QLabel {
                border: 2px dashed #666;
                border-radius: 10px;
                padding: 20px;
                font-size: 14px;
                color: #aaa;
            }
        """)
        self.main_layout.addWidget(self.label_drop_zone)

    def _setup_info_labels(self):
        self.label_files_info = QLabel("No files loaded", self)
        self.label_files_info.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.main_layout.addWidget(self.label_files_info)
        
        self.label_total_records = QLabel("Total Records: 0", self)
        self.label_total_records.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.label_total_records.setStyleSheet("font-weight: bold; font-size: 12px;")
        self.main_layout.addWidget(self.label_total_records)

    def _setup_top_buttons(self):
        layout = QHBoxLayout()
        self.button_load = QPushButton("Add Files...", self)
        self.button_load.clicked.connect(self.handle_load_button)
        layout.addWidget(self.button_load)

        self.button_clear = QPushButton("Clear All", self)
        self.button_clear.setStyleSheet("color: #ff9999;")
        self.button_clear.clicked.connect(self.handle_clear_data)
        layout.addWidget(self.button_clear)
        self.main_layout.addLayout(layout)

    def _setup_instruction_label(self):
        lbl = QLabel("Select fields to KEEP (unchecked will be removed):", self)
        lbl.setStyleSheet("color: gray; margin-top: 10px;")
        self.main_layout.addWidget(lbl)

    def _setup_grid_area(self):
        self.scroll_area = QScrollArea(self)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setFrameShape(QScrollArea.Shape.NoFrame)
        
        self.scroll_content = QWidget()
        self.grid_layout = QGridLayout(self.scroll_content)
        self.grid_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.scroll_area.setWidget(self.scroll_content)
        self.main_layout.addWidget(self.scroll_area)

    def _setup_action_buttons(self):
        layout = QHBoxLayout()
        self.button_toggle = QPushButton("Show all fields", self)
        self.button_toggle.setCheckable(True)
        self.button_toggle.clicked.connect(self.handle_toggle_view)
        layout.addWidget(self.button_toggle)

        self.button_reset = QPushButton("Reset Selection", self)
        self.button_reset.clicked.connect(self.handle_reset_defaults)
        layout.addWidget(self.button_reset)
        self.main_layout.addLayout(layout)

    def _setup_options(self):
        layout = QHBoxLayout()
        self.checkbox_dedupe = QCheckBox("Remove Duplicates (Call, Band, Mode, Date, Time)")
        self.checkbox_dedupe.setChecked(True)
        layout.addWidget(self.checkbox_dedupe)
        self.main_layout.addLayout(layout)

    def _setup_process_button(self):
        self.button_process = QPushButton("Merge, Process and Save", self)
        self.button_process.setMinimumHeight(45)
        self.button_process.setStyleSheet("font-weight: bold;")
        self.button_process.setEnabled(False)
        self.button_process.clicked.connect(self.handle_process_file)
        self.main_layout.addWidget(self.button_process)

    def _setup_footer(self):
        lbl = QLabel("Created by Leszek HF7A | License: MIT", self)
        lbl.setAlignment(Qt.AlignmentFlag.AlignCenter)
        lbl.setStyleSheet("color: gray; font-size: 10px;")
        self.main_layout.addWidget(lbl)

    def dragEnterEvent(self, event: QDragEnterEvent) -> None:
        if event.mimeData().hasUrls():
            event.accept()
            self.label_drop_zone.setStyleSheet("QLabel { border: 2px solid #4CAF50; border-radius: 10px; padding: 20px; color: #fff; background-color: #333; }")
        else:
            event.ignore()
            
    def dragLeaveEvent(self, event) -> None:
        self._reset_dropzone_style()

    def dropEvent(self, event: QDropEvent) -> None:
        urls = event.mimeData().urls()
        if urls:
            files = [Path(u.toLocalFile()) for u in urls if Path(u.toLocalFile()).suffix.lower() in ['.adi', '.adif']]
            if files:
                self._process_incoming_files(files)
            else:
                QMessageBox.warning(self, "Invalid File", "Please drop valid .adi/.adif files.")
        self._reset_dropzone_style()

    def _reset_dropzone_style(self):
        color = "#4CAF50" if self.processor.records else "#666"
        text_color = "#4CAF50" if self.processor.records else "#aaa"
        border = "solid" if self.processor.records else "dashed"
        
        self.label_drop_zone.setStyleSheet(f"""
            QLabel {{
                border: 2px {border} {color};
                border-radius: 10px;
                padding: 20px;
                font-size: 14px;
                color: {text_color};
            }}
        """)

    def handle_load_button(self) -> None:
        fpaths, _ = QFileDialog.getOpenFileNames(self, "Select ADIF Files", "", "ADIF (*.adi *.adif)")
        if fpaths:
            self._process_incoming_files([Path(p) for p in fpaths])

    def handle_clear_data(self) -> None:
        self.processor.clear_data()
        self.label_files_info.setText("No files loaded")
        self.label_total_records.setText("Total Records: 0")
        self.button_process.setEnabled(False)
        self._init_checkbox_objects()
        self._reset_dropzone_style()

    def _process_incoming_files(self, files: List[Path]) -> None:
        new_count, total_count, errors = self.processor.add_adif_files(files)
        
        if errors:
            error_msg = "\n".join(errors[:5])
            if len(errors) > 5:
                error_msg += f"\n...and {len(errors) - 5} more errors."
            QMessageBox.warning(self, "Load Errors", f"Some files could not be read:\n{error_msg}")

        count_files = len(self.processor.loaded_files)
        file_names = "\n".join([f.name for f in self.processor.loaded_files])
        
        if count_files == 1:
            self.label_files_info.setText(f"File: {self.processor.loaded_files[0].name}")
        else:
            self.label_files_info.setText(f"Loaded {count_files} files (Hover to see list)")
            self.label_files_info.setToolTip(file_names)

        self.label_total_records.setText(f"Total Records: {total_count}")
        
        self._init_checkbox_objects()
        self._refresh_grid_layout()
        if total_count > 0:
            self.button_process.setEnabled(True)
        self._reset_dropzone_style()

    def _init_checkbox_objects(self) -> None:
        self._clear_layout()
        self.field_checkboxes.clear()
        current_selection = self.saved_fields 
        for field in self.processor.get_unique_fields():
            cb = QCheckBox(field)
            if field in current_selection:
                cb.setChecked(True)
            self.field_checkboxes[field] = cb

    def _clear_layout(self) -> None:
        while self.grid_layout.count():
            child = self.grid_layout.takeAt(0)
            if child.widget():
                child.widget().setParent(None)

    def _refresh_grid_layout(self) -> None:
        self._clear_layout()
        show_all = self.button_toggle.isChecked()
        row, col = 0, 0
        for field in sorted(self.field_checkboxes.keys()):
            cb = self.field_checkboxes[field]
            if show_all or cb.isChecked():
                self.grid_layout.addWidget(cb, row, col)
                cb.setVisible(True)
                col += 1
                if col >= GRID_COLUMNS:
                    col = 0
                    row += 1
        self.button_toggle.setText("Hide unchecked fields" if show_all else "Show all fields")

    def handle_toggle_view(self) -> None:
        self._refresh_grid_layout()

    def handle_reset_defaults(self) -> None:
        if not self.field_checkboxes: return
        if QMessageBox.question(self, "Confirm", "Reset selection?") == QMessageBox.StandardButton.Yes:
            for field, checkbox in self.field_checkboxes.items():
                checkbox.setChecked(field in DEFAULT_FIELDS)
            self._refresh_grid_layout()

    def handle_process_file(self) -> None:
        selected = {f for f, cb in self.field_checkboxes.items() if cb.isChecked()}
        dedupe = self.checkbox_dedupe.isChecked()
        
        if not selected:
            QMessageBox.warning(self, "Warning", "Select at least one field.")
            return

        self.processor.save_config(selected)
        self.saved_fields = selected

        if self.processor.loaded_files:
             default_name = self.processor.loaded_files[0].with_name("filtered_output.adi")
        else:
             default_name = "output.adi"

        out_path, _ = QFileDialog.getSaveFileName(self, "Save ADIF", str(default_name), "ADIF (*.adi)")
        
        if out_path:
            try:
                count, duplicates_removed = self.processor.save_adif_file(Path(out_path), selected, dedupe)
                
                msg = f"Saved {count} records to:\n{out_path}"
                if dedupe:
                    msg += f"\n\nDuplicates removed: {duplicates_removed}"
                
                QMessageBox.information(self, "Success", msg)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save:\n{e}")

def main():
    app = QApplication(sys.argv)
    window = AdifFilterWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()